<?php
/**
 * class-ep-provision-util.php
 *
 * eqpress provisioning utility class
 *
 */

class EP_Provision_Util
{
  /**
   * Validate and sanitize POST parameters
   *
   */
  public function validate_post_parameters()
  {
    global $params;

    if (isset($_POST['email']) && !empty($_POST['email'])) {
      if ($this->is_valid_email_address($_POST['email'])) {
        $params['email'] = $_POST['email'];
      } else {
        $params['status']['errors']++;
        $params['status']['messages'][] = 'Email address is invalid';
      }
    } else {
      $params['status']['errors']++;
      $params['status']['messages'][] = 'Email address is missing';
    }

    if (isset($_POST['location']) && !empty($_POST['location'])) {
      $params['location'] = $_POST['location'];
    }

    if (isset($_POST['domain']) && !empty($_POST['domain'])) {
      $domain = $this->sanitize_domain($_POST['domain']);
      if ($this->is_valid_domain($domain)) {
        $params['domain'] = $domain;
      } else {
        $params['status']['errors']++;
        $params['status']['messages'][] = 'Domain name is invalid: ' . $domain;
      }
    } else {
      $params['status']['errors']++;
      $params['status']['messages'][] = 'Domain name is missing';
    }

    if (isset($_POST['first_name']) && !empty($_POST['first_name'])) {
      $params['real_first_name'] = htmlspecialchars($_POST['first_name']);
      $params['first_name'] = $this->sanitize_name($_POST['first_name']);
    } else {
      $params['status']['errors']++;
      $params['status']['messages'][] = 'First name is missing';
    }

    if (isset($_POST['last_name']) && !empty($_POST['last_name'])) {
      $params['real_last_name'] = htmlspecialchars($_POST['last_name']);
      $params['last_name'] = $this->sanitize_name($_POST['last_name']);
    } else {
      $params['status']['errors']++;
      $params['status']['messages'][] = 'Last name is missing';
    }

    if (
      isset($_POST['multisite']) &&
      ($_POST['multisite'] == 'subdomain' ||
        $_POST['multisite'] == 'subdirectory')
    ) {
      $params['multisite'] = $_POST['multisite'];
    } else {
      $params['multisite'] = false;
    }

    if (isset($_POST['db_charset'])) {
      $params['db_charset'] = $_POST['db_charset'];
    }

    if (isset($_POST['db_collate'])) {
      $params['db_collate'] = $_POST['db_collate'];
    }

    if (isset($_POST['rpdns_user']) && !empty($_POST['rpdns_user'])) {
      $params['rpdns_user'] = $_POST['rpdns_user'];
    }

    if (
      isset($_POST['bcc_email']) &&
      !empty($_POST['bcc_email']) &&
      $this->is_valid_email_address($_POST['bcc_email'])
    ) {
      $params['bcc_email'] = $_POST['bcc_email'];
    }

    if (
      isset($_POST['alert_email']) &&
      !empty($_POST['alert_email']) &&
      $this->is_valid_email_address($_POST['alert_email'])
    ) {
      $params['alert_email'] = $_POST['alert_email'];
    }
  }

  /**
   * Authenticate the request
   *
   */
  public function authenticate($username, $password, $source)
  {
    global $params;

    $isauth = false;

    if (preg_match('/^[A-Za-z0-9_\.\-]+$/', $source)) {
      // testing for now FIXME -- We need to do a api key check here
      $isauth = true;
    } elseif (preg_match('/^[A-Za-z0-9_\.\-]+$/', $username)) {
      $isauth = $this->ldap_auth(
        $username,
        $password,
        $params['ldap_auth_attrib'],
        $params['ldap_auth_basedn'],
        $params['ldap_auth_server'],
        $params['ldap_auth_port']
      );
    }

    if (!$isauth) {
      $this->process_errors('Incorrect username or password.', true);
    }
  }

  /**
   * LDAP authencation function
   * Separated from function "authenticate" as in the future there might be
   * other ways of authenticating users
   *
   */
  private function ldap_auth(
    $user,
    $pass,
    $authattribute,
    $basedn,
    $server,
    $port
  ) {
    $ldap_conn = ldap_connect($server, $port);
    if ($ldap_conn) {
      ldap_set_option($ldap_conn, LDAP_OPT_PROTOCOL_VERSION, 3);
      return ldap_bind(
        $ldap_conn,
        $authattribute . '=' . $user . ',' . $basedn,
        $pass
      );
    }
    return false;
  }

  /**
   * Process errors
   *
   * @param string $message is the error message to write to the log and/or screen.
   * @param boolean $exit_now will determine whether or not to terminate the process.
   *
   */
  public function process_errors($message, $exit_now = false)
  {
    global $params;
    $params['status']['errors']++;
    $params['status']['messages'][] = $message;
    if ($exit_now) {
      header('Content-Type: application/json; charset=utf-8');
      echo json_encode($params['status']);
      $this->sanitize_params();
      file_put_contents(
        EP_PROV_DIR . '{{ auto_provision_log_file }}',
        "\n" .
          date(DATE_RFC850) .
          ' (request ' .
          $params['request_id'] .
          ' failed): ' .
          serialize($params) .
          "\n",
        FILE_APPEND | LOCK_EX
      );
      exit();
    }
  }

  /**
   * Validate an email address.
   *
   * @param string $email is the email address.
   * @return boolean
   *
   */
  public function is_valid_email_address($email)
  {
    if (filter_var($email, FILTER_VALIDATE_EMAIL)) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Check for an existing domain.
   *
   * @param string $domain is the domain name of the site being installed.
   * @return boolean letting the caller know if the domain exists.
   *
   */
  public function domain_exists($domain)
  {
    $dir = '/etc/nginx/sites-available/';
    $exists = false;
    if (is_dir($dir)) {
      if ($dh = opendir($dir)) {
        while (($file = readdir($dh)) !== false) {
          if ($domain == $file) {
            $exists = true;
          }
        }
      }
      closedir($dh);
    }
    return $exists;
  }

  /**
   * Validate a domain name.
   *
   * @param string $domain is the domain name of the site to install.
   * @return boolean
   *
   */
  public function is_valid_domain($domain)
  {
    $ctr = 0;
    $pieces = explode('.', $domain);
    if (($num_pieces = sizeof($pieces)) < 2) {
      return false;
    }
    foreach ($pieces as $piece) {
      $ctr++;
      if (
        !preg_match('/^[a-z\d][a-z\d-]{0,62}$/i', $piece) ||
        preg_match('/-$/', $piece)
      ) {
        return false;
      }
    }
    return true;
  }

  /**
   * Sanitize the domain name.
   *
   * @param string $domain is the domain name of the site to install.
   * @return string $domain sanitized
   *
   */
  public function sanitize_domain($domain)
  {
    $domain = strtolower($domain);
    $domain = preg_replace('/^ /', '', $domain);
    $domain = preg_replace('/ $/', '', $domain);
    $domain = preg_replace('#^https?://#', '', $domain);
    return $domain;
  }

  /**
   * Remove sensitive data from the $params variable before writing to log files.
   *
   */
  public function sanitize_params()
  {
    global $params;
    $params['ep_api_key'] = 'sanitized';
    $params['db_pass'] = 'sanitized';
    $params['wpadmin_pass'] = 'sanitized';
    $params['sftp_pass'] = 'sanitized';
    $params['pwp']['db'] = 'sanitized';
    $params['pwp']['sftp'] = 'sanitized';
    $params['pwp']['wp'] = 'sanitized';
  }

  /**
   * Specify the name of the database using the domain name.
   *
   * Return everything but the top level domain and trim everything after
   * 60 chars and add a random string to the end. Replace all dots with
   * underscores.
   *
   * @param string $domain is the domain name of the site to install.
   *
   */
  public function give_the_db_a_name($domain)
  {
    global $params;
    $ctr = 0;
    $subdomain = '';
    $pieces = explode('.', $domain);
    $num_pieces = sizeof($pieces);
    foreach ($pieces as $piece) {
      $ctr++;
      $subdomain .= $piece . '_';
      if ($ctr == $num_pieces) {
        $subdomain = substr($subdomain, 0, 58);
        $params['db_name'] = $subdomain . $this->random(3);
      }
    }
  }

  /**
   * Strip non-ascii characters from first and last name
   *
   * @param string $name is part of the name.
   * @return string $s_name is the sanitized name.
   *
   */
  public function sanitize_name($name)
  {
    $char_swap = [
      'Š' => 'S',
      'š' => 's',
      'Ž' => 'Z',
      'ž' => 'z',
      'À' => 'A',
      'Á' => 'A',
      'Â' => 'A',
      'Ã' => 'A',
      'Ä' => 'A',
      'Å' => 'A',
      'Æ' => 'A',
      'Ç' => 'C',
      'È' => 'E',
      'É' => 'E',
      'Ê' => 'E',
      'Ë' => 'E',
      'Ì' => 'I',
      'Í' => 'I',
      'Î' => 'I',
      'Ï' => 'I',
      'Ñ' => 'N',
      'Ò' => 'O',
      'Ó' => 'O',
      'Ô' => 'O',
      'Õ' => 'O',
      'Ö' => 'O',
      'Ø' => 'O',
      'Ù' => 'U',
      'Ú' => 'U',
      'Û' => 'U',
      'Ü' => 'U',
      'Ý' => 'Y',
      'Þ' => 'B',
      'à' => 'a',
      'á' => 'a',
      'â' => 'a',
      'ã' => 'a',
      'ß' => 'ss',
      'ä' => 'a',
      'å' => 'a',
      'æ' => 'a',
      'ç' => 'c',
      'è' => 'e',
      'é' => 'e',
      'ê' => 'e',
      'ë' => 'e',
      'ì' => 'i',
      'í' => 'i',
      'î' => 'i',
      'ï' => 'i',
      'ð' => 'o',
      'ñ' => 'n',
      'ò' => 'o',
      'ó' => 'o',
      'ô' => 'o',
      'õ' => 'o',
      'ö' => 'o',
      'ø' => 'o',
      'ù' => 'u',
      'ú' => 'u',
      'û' => 'u',
      'ý' => 'y',
      'þ' => 'b',
      'ÿ' => 'y',
      'Ğ' => 'G',
      'İ' => 'I',
      'Ş' => 'S',
      'ğ' => 'g',
      'ı' => 'i',
      'ş' => 's',
      'ü' => 'u',
      'ă' => 'a',
      'Ă' => 'A',
      'ș' => 's',
      'Ș' => 'S',
      'ț' => 't',
      'Ț' => 'T',
      'ł' => 'l',
    ];
    $s_name = strtr($name, $char_swap);
    $s_name = preg_replace('/[^a-zA-Z0-9]/', '', $s_name);
    return $s_name;
  }

  /**
   * Return a random string
   *
   * @param int $len is the length of the random string to generate.
   * @param bool $alphanum specifies if the random string should be alphanumeric
   * @return string containing the random string.
   */
  public function random($len = 23, $alphanum = true)
  {
    if ($alphanum === true) {
      $chars = '/[0-9A-Za-z]/';
    } else {
      $chars = '/[\x20-\x7E]/';
    }
    // exclude single quotes, double quotes and backslash from random strings
    $excluded_chars = '/[\x22\x27\x5C]/';
    $rs = '';
    $f = fopen($_SERVER['EP_DEV_RAND'], 'r');
    if ($f == false) {
      $f = fopen('/dev/urandom', 'r');
      if ($f == false) {
        $this->process_errors(
          'Could not open ' . $_SERVER['EP_DEV_RAND'],
          true
        );
      }
    }
    for ($x = 0; $x < $len; $x++) {
      $c = fgetc($f);
      if (preg_match($excluded_chars, $c)) {
        $x--;
      } elseif (preg_match($chars, $c)) {
        $rs .= $c;
      } else {
        $x--;
      }
    }
    fclose($f);
    return $rs;
  }

  /**
   * Generate the keys and salts
   *
   * @return string $keysalts
   */
  public function generate_keysalts()
  {
    $keysalts =
      "define('AUTH_KEY',         '" .
      $this->random(64, false) .
      "');\n" .
      "define('SECURE_AUTH_KEY',  '" .
      $this->random(64, false) .
      "');\n" .
      "define('LOGGED_IN_KEY',    '" .
      $this->random(64, false) .
      "');\n" .
      "define('NONCE_KEY',        '" .
      $this->random(64, false) .
      "');\n" .
      "define('AUTH_SALT',        '" .
      $this->random(64, false) .
      "');\n" .
      "define('SECURE_AUTH_SALT', '" .
      $this->random(64, false) .
      "');\n" .
      "define('LOGGED_IN_SALT',   '" .
      $this->random(64, false) .
      "');\n" .
      "define('NONCE_SALT',       '" .
      $this->random(64, false) .
      "');";
    return $keysalts;
  }

  /**
   * Generate the passwords
   *
   */
  // FIXME: convert to use RAMPASS
  public function generate_credentials()
  {
    global $params;

    $this->give_the_db_a_name($params['domain']); // Set the DB name and store it in $params['db_name'].
    $params['db_pass'] = $this->random();
    $params['db_user'] =
      substr($params['last_name'], 0, 12) . '_' . $this->random(3);
    $params['db_prefix'] = $this->random(8) . '_';
    $params['sftp_pass'] = $this->random();
    $params['wpadmin_pass'] = $this->random();

    // Default units for password expiry is in days but if we're testing make it minutes.
    $units = 'days';
    if ($params['location'] == 'dev') {
      $units = 'minutes';
    }
    // FIXME: for RAMPASS TEST TEST TEST
    $rampass_post_array_defaults = [
      'time' => 30,
      'units' => '' . $units . '',
      'views' => 5,
    ];

    // For $params['pwp']['db']
    $post_data = array_merge($rampass_post_array_defaults, [
      'secret' => $params['db_pass'],
    ]);
    $response = $this->http_req([
      'post_fields' => json_encode($post_data),
      'header' => ['Content-Type: application/json'],
    ]);
    $params['pwp']['db'] = json_decode($response['body'])->data->url;

    // For $params['pwp']['wp']
    $post_data = array_merge($rampass_post_array_defaults, [
      'secret' => $params['wpadmin_pass'],
    ]);
    $response = $this->http_req([
      'post_fields' => json_encode($post_data),
      'header' => ['Content-Type: application/json'],
    ]);
    $params['pwp']['wp'] = json_decode($response['body'])->data->url;

    // For $params['pwp']['sftp']
    $post_data = array_merge($rampass_post_array_defaults, [
      'secret' => $params['sftp_pass'],
    ]);
    $response = $this->http_req([
      'post_fields' => json_encode($post_data),
      'header' => ['Content-Type: application/json'],
    ]);
    $params['pwp']['sftp'] = json_decode($response['body'])->data->url;
  }

  /**
   * Create the tmp directory to hold the configuration files.
   *
   */
  public function create_config_dir()
  {
    if (!mkdir(EP_TMP_DIR, 0700, true)) {
      $this->process_errors(
        'Could not create config directory: ' . EP_TMP_DIR,
        true
      );
    }
  }

  /**
   * Move the tmp directory into the pending state, ready to be processed by monit_ep_provision.sh.
   *
   */
  public function move_config_dir()
  {
    global $params;
    // retry if the directory already exists, loop, sleep, retry, 5 times then fail
    if (!rename(EP_TMP_DIR, EP_PEND_DIR . $params['domain'])) {
      $this->process_errors(
        'Could not move config directory ' . EP_TMP_DIR . ' to ' . EP_PEND_DIR,
        true
      );
    }
    if (!rmdir(EP_TMP)) {
      $this->process_errors(
        'Could not delete config directory: ' . EP_TMP,
        false
      );
    }
  }

  /**
   * Create wp_config.php.
   *
   */
  public function create_wp_config()
  {
    global $params, $mustache;
    $ep_secret_key = $params['domain'] . $_SERVER['CONSOLE_API_KEY_SECRET'];
    $params['ep_api_key'] = md5($ep_secret_key);
    $keysalts = $this->generate_keysalts();
    $params['db_prefix'] = $this->random(8) . '_';

    $tpl = $mustache->loadTemplate('wp-config.php');
    $out = $tpl->render([
      'dbhost' => $params['db_host'],
      'dbname' => $params['db_name'],
      'dbuser' => $params['db_user'],
      'dbpass' => $params['db_pass'],
      'dbprefix' => $params['db_prefix'],
      'dbcharset' => $params['db_charset'],
      'dbcollate' => $params['db_collate'],
      'ep_api_key' => $params['ep_api_key'],
      'keysalts' => $keysalts,
    ]);

    $file = EP_TMP_DIR . '/wp-config.php';
    if (!file_put_contents($file, $out)) {
      $this->process_errors("Could not create $file", true);
    }
  }

  /**
   * Create the nginx virtual host config file.
   *
   */
  public function create_nginx_config()
  {
    global $params, $mustache;
    $multisite_config = '';
    $multisite_subdir_config = '';
    $lua_config_root = '';
    $lua_config_php = '';

    if ($params['multisite'] !== false) {
      $domain = $params['domain'];
      $multisite_config = <<<EOT
    server_name *.$domain;

    server_name_in_redirect off;
EOT;
      if ($params['multisite'] == 'subdirectory') {
        $multisite_subdir_config = <<<EOT
    include /etc/nginx/eqpress-common/common_multisite_3.5.conf;
EOT;
      }
    }

    if ($params['location'] != 'ca1') {
      $lua_config_root = <<<EOLUA
        access_by_lua_file /etc/nginx/eqpress-common/lua_block_post_noreferrer.lua;
EOLUA;
    }

    if ($params['location'] != 'ca1') {
      $lua_config_php = <<<EOLUA
        access_by_lua_file /etc/nginx/eqpress-common/lua_block_wplogin_noreferrer.lua;
EOLUA;
    }

    $tpl = $mustache->loadTemplate('nginx-config');
    $out = $tpl->render([
      'domain' => $params['domain'],
      'multisite_config' => $multisite_config,
      'multisite_subdir_config' => $multisite_subdir_config,
      'lua_config_root' => $lua_config_root,
      'lua_config_php' => $lua_config_php,
    ]);
    $file = EP_TMP_DIR . '/' . $params['domain'] . '_ngx.conf';
    if (!file_put_contents($file, $out)) {
      $this->process_errors("Could not create $file", true);
    }
  }

  /**
   * Create ansible playbook
   *
   */
  public function create_ansible_playbook()
  {
    global $params, $mustache;
    $multisite_config = '';
    $switch_to_dev = '';
    $console = '';
    $domain = $params['domain'];
    $from_email = '{{ org_support_email }} ({{ org_name }} Support)';
    $subject = "Your WordPress site for $domain is ready!";

    if ($params['multisite'] !== false) {
      if ($params['multisite'] == 'subdomain') {
        $multisite_config = <<<EOT
  - name: Convert WordPress installation to multisite subdomains
    become: true
    command: chdir=/var/www/$domain/wordpress /usr/local/sbin/wp --allow-root core multisite-convert --subdomains

EOT;
      }
      if ($params['multisite'] == 'subdirectory') {
        $multisite_config = <<<EOT
  - name: Convert WordPress installation to multisite subdirectories
    become: true
    command: chdir=/var/www/$domain/wordpress /usr/local/sbin/wp --allow-root core multisite-convert

EOT;
      }

      // install multisite domain mapping plugin
      $multisite_config .= <<<EOT
  - name: Install domain mapping plugin
    become: true
    command: chdir=/var/www/$domain/wordpress /usr/local/sbin/wp --allow-root plugin install wordpress-mu-domain-mapping --activate-network

  - stat: path=/var/www/$domain/wordpress/wp-content/sunrise.php
    become: true
    register: sunrise_file

  - name: move sunrise file into wp-content directory
    become: true
    command: /bin/mv /var/www/$domain/wordpress/wp-content/plugins/wordpress-mu-domain-mapping/sunrise.php /var/www/$domain/wordpress/wp-content
    when: sunrise_file.stat.exists == False

  - name: add surise constant to wp-config.php
    become: true
    lineinfile: dest=/var/www/$domain/wordpress/wp-config.php state=present insertafter=EP_CACHE_OPTIONS line="define('SUNRISE', 'on');"

EOT;
    } // end of multisite config

    $console = <<<EOE
  - name: Install Console as must-use plugins for $domain
    become: true
    command: /usr/local/sbin/eq_install_console.sh $domain creates=/var/www/$domain/wordpress/wp-content/mu-plugins/eqpress.php
    ignore_errors: yes

EOE;

    // Get the name of the server that ansible will use to install the site.
    $server = $params['nodes'][$params['location']]['hostname'];
    $tpl = $mustache->loadTemplate('ep-provision.yml');
    $out = $tpl->render([
      'prov_dir' => EP_PROV_DIR,
      'server' => $server,
      'domain' => $params['domain'],
      'email' => $params['email'],
      'first_name' => $params['real_first_name'],
      'last_name' => $params['real_last_name'],
      'wpadmin_user' => $params['first_name'],
      'wpadmin_pass' => $params['wpadmin_pass'],
      'wpadmin_email' => $params['email'],
      'multisite_config' => $multisite_config,
      'db_host' => $params['db_host'],
      'db_name' => $params['db_name'],
      'db_user' => $params['db_user'],
      'db_pass' => $params['db_pass'],
      'db_charset' => $params['db_charset'],
      'db_collate' => $params['db_collate'],
      'web_user' => $params['web_user'],
      'web_group' => $params['web_group'],
      'sftp_pass' => $params['sftp_pass'],
      'sftp_user' => $params['db_user'],
      'bcc_email' => $params['bcc_email'],
      'alert_email' => $params['alert_email'],
      'from_email' => $from_email,
      'subject' => $subject,
      'switch_to_dev' => $switch_to_dev,
      'console' => $console,
    ]);
    $file = EP_TMP_DIR . '/provision.yml';
    if (!file_put_contents($file, $out)) {
      $this->process_errors("Could not create $file", true);
    }
  }

  /**
   * Create the welcome email message we send to the customer.
   *
   */
  public function create_welcome_email()
  {
    global $params, $mustache;
    $domain = $params['domain'];
    $welcome_email_template = 'welcome-email.txt.mustache';

    // Get the IP address of the server.
    $server_ip = $params['nodes'][$params['location']]['ip'];

    // Create the email from the template
    $tpl = $mustache->loadTemplate($welcome_email_template);
    $out = $tpl->render([
      'domain' => $domain,
      'email' => $params['email'],
      'first_name' => $params['real_first_name'],
      'last_name' => $params['real_last_name'],
      'wp_admin' => $params['first_name'],
      'db_name' => $params['db_name'],
      'db_user' => $params['db_user'],
      'sftp_user' => $params['db_user'],
      'pwp_wp' => $params['pwp']['wp'],
      'pwp_db' => $params['pwp']['db'],
      'pwp_sftp' => $params['pwp']['sftp'],
      'server_ip' => $server_ip,
      'org_name' => $params['org_name'],
      'org_email' => $params['org_email'],
    ]);

    // Save the parsed template to a file to be read by ansible process.
    $file = EP_TMP_DIR . '/welcome-email.txt';
    if (!file_put_contents($file, $out)) {
      $this->process_errors("Could not create $file", true);
    }
  }

  /**
   * HTTP requests
   *
   * @param array $request should minimally contain the POST arguments.
   * @return array containing HTTP response code, the body of the response, elapsed time.
   */

  public function http_req($request = [])
  {
    global $params;
    $url = '{{ rampass_url }}/api';
    $response = [];
    $defaults = [
      'url' => $url,
      'method' => 'POST',
      'timeout' => 30,
      'verbose' => 0,
    ];
    $request = array_merge($defaults, $request);
    try {
      $mych = new CurlRequest();
      $mych->init($request);
      $response = $mych->exec();
      if ($response['curl_error']) {
        throw new Exception($response['curl_error']);
      }
      if (null === $response['body']) {
        throw new Exception('Body of response is empty');
      }
    } catch (Exception $e) {
      $this->process_errors(
        'http_req error: ' . $e->getMessage() . "\n" . print_r($response, true)
      );
    }
    return $response;
  }
}
